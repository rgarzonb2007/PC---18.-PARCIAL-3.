# -*- coding: utf-8 -*-
"""PC - 18. PARCIAL #3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13_ZxQcbabljqo-aK1h8U277xRhVGnLkX
"""

import time
from rx import create, operators as ops

# Función que simula la entrada de datos, como si un usuario estuviera escribiendo.
def simulate_input(observer, scheduler):
    # Simulamos una secuencia de entradas (por ejemplo, mientras se escribe "python")
    entradas = ["p", "py", "pyt", "pyth", "pytho", "python"]
    for texto in entradas:
        observer.on_next(texto)
        time.sleep(0.2)  # Simula el tiempo entre pulsaciones (200 ms)
    observer.on_completed()

# Creamos un observable a partir de la función simulate_input
observable = create(simulate_input)

# Aplicamos operadores para transformar el flujo:
# - debounce: espera 500 ms de inactividad para emitir el último valor.
# - filter: descarta entradas con menos de 3 caracteres.
# - map: transforma el texto a mayúsculas (como ejemplo de procesamiento).
procesado = observable.pipe(
    ops.debounce(0.5),   # Espera 500 ms de inactividad
    ops.filter(lambda s: len(s) > 2),  # Procesa solo si la entrada tiene más de 2 caracteres
    ops.map(lambda s: s.upper())       # Convierte el texto a mayúsculas
)

# Funciones de suscripción para manejar la salida del observable.
def on_next(valor):
    print(f"Entrada procesada: {valor}")

def on_error(error):
    print(f"Error: {error}")

def on_completed():
    print("Procesamiento completado.")

# Nos suscribimos al observable procesado
procesado.subscribe(
    on_next=on_next,
    on_error=on_error,
    on_completed=on_completed
)

# Mantenemos el programa en ejecución el tiempo suficiente para procesar todas las entradas.
time.sleep(3)